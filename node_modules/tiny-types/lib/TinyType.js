"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinyType = exports.TinyTypeOf = void 0;
var ensure_1 = require("./ensure");
var objects_1 = require("./objects");
var predicates_1 = require("./predicates");
/**
 * @desc The {@link TinyTypeOf} can be used to define simple
 * single-value {@link TinyType}s on a single line.
 *
 * It contains a check preventing the constructor argument from being undefined (see {@link isDefined});
 *
 * @experimental
 *
 * @example
 * class Username extends TinyTypeOf<string>() {}
 *
 * @example
 * class Age extends TinyTypeOf<number>() {}
 *
 * @returns a dynamically created base class your tiny type can extend from
 */
function TinyTypeOf() {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1(value) {
            var _this = _super.call(this) || this;
            _this.value = value;
            ensure_1.ensure(_this.constructor.name, value, predicates_1.isDefined());
            return _this;
        }
        return class_1;
    }(TinyType));
}
exports.TinyTypeOf = TinyTypeOf;
/**
 * @desc The {@link TinyType} abstract class should be used as a base class for your own Tiny Types.
 *
 * If you want the Tiny Type to wrap a single value use the {@link TinyTypeOf} instead as it will save you some keystrokes.
 *
 * @example
 * class FirstName extends TinyTypeOf<string>() {}
 * class LastName  extends TinyTypeOf<string>() {}
 * class Age       extends TinyTypeOf<number>() {}
 *
 * class Person extends TinyType {
 *   constructor(public readonly firstName: FirstName,
 *               public readonly lastName:  LastName,
 *               public readonly age:       Age,
 *   ) {
 *     super();
 *   }
 * }
 */
var TinyType = /** @class */ (function () {
    function TinyType() {
    }
    // todo: can I make all fields `readonly` without making it a dictionary?
    /**
     * @desc Compares two tiny types by value
     *
     * @example <caption>Comparing simple types</caption>
     * class Id extends TinyTypeOf<string>() {}
     *
     * const id = new Id(`3cc0852d-fda7-4f61-874e-0cfadbd6182a`);
     *
     * id.equals(id) === true
     *
     * @example <caption>Comparing complex types recursively</caption>
     * class FirstName extends TinyTypeOf<string>() {}
     * class LastName  extends TinyTypeOf<string>() {}
     * class Age       extends TinyTypeOf<number>() {}
     *
     * class Person extends TinyType {
     *   constructor(public readonly firstName: FirstName,
     *               public readonly lastName:  LastName,
     *               public readonly age:       Age,
     *   ) {
     *     super();
     *   }
     * }
     *
     * const p1 = new Person(new FirstName('John'), new LastName('Smith'), new Age(42)),
     *       p2 = new Person(new FirstName('John'), new LastName('Smith'), new Age(42));
     *
     * p1.equals(p2) === true
     *
     * @param {TinyType} another
     * @returns {boolean}
     */
    TinyType.prototype.equals = function (another) {
        return objects_1.equal(this, another);
    };
    TinyType.prototype.toString = function () {
        return objects_1.stringify(this);
    };
    /**
     * @desc Serialises the object to a JSON representation.
     *
     * @example
     * class FirstName extends TinyTypeOf<string>() {}
     *
     * const name = new FirstName('Jan');
     *
     * name.toJSON() === 'Jan'
     *
     * @example
     * class FirstName extends TinyTypeOf<string>() {}
     * class LastName  extends TinyTypeOf<string>() {}
     * class Age       extends TinyTypeOf<number>() {}
     *
     * class Person extends TinyType {
     *   constructor(public readonly firstName: FirstName,
     *               public readonly lastName:  LastName,
     *               public readonly age:       Age,
     *   ) {
     *     super();
     *   }
     * }
     *
     * const person = new Person(new FirstName('John'), new LastName('Smith'), new Age(42)),
     *
     * person.toJSON() === { firstName: 'John', lastName: 'Smith', age: 42 }
     *
     * @returns {JSONValue}
     */
    TinyType.prototype.toJSON = function () {
        var _this = this;
        var isObject = function (value) { return Object(value) === value; }, isSerialisablePrimitive = function (value) {
            return !!~['string', 'boolean', 'null', 'undefined'].indexOf(typeof value) ||
                (typeof value === 'number' && !isNaN(value) && !~[Infinity, -Infinity].indexOf(value));
        };
        function toJSON(value) {
            switch (true) {
                case value && !!value.toJSON:
                    return value.toJSON();
                case value && Array.isArray(value):
                    return value.map(function (v) { return toJSON(v); });
                case value && isObject(value):
                    return JSON.parse(JSON.stringify(value));
                case isSerialisablePrimitive(value):
                    return value;
                default:
                    return JSON.stringify(value);
            }
        }
        var fields = objects_1.significantFieldsOf(this);
        if (fields.length === 1) {
            return toJSON(this[fields[0]]);
        }
        return fields.reduce(function (acc, field) {
            acc[field] = toJSON(_this[field]);
            return acc;
        }, {});
    };
    return TinyType;
}());
exports.TinyType = TinyType;
//# sourceMappingURL=TinyType.js.map