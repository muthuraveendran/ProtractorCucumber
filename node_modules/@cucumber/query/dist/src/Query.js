"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("@cucumber/messages");
const multimaps_1 = require("@teppeis/multimaps");
class Query {
    constructor() {
        this.testStepResultByPickleId = new multimaps_1.ArrayMultimap();
        this.testStepResultsByPickleStepId = new multimaps_1.ArrayMultimap();
        this.testStepById = new Map();
        this.testCaseByPickleId = new Map();
        this.pickleIdByTestStepId = new Map();
        this.pickleStepIdByTestStepId = new Map();
        this.testStepResultsbyTestStepId = new multimaps_1.ArrayMultimap();
        this.testStepIdsByPickleStepId = new multimaps_1.ArrayMultimap();
        this.hooksById = new Map();
        this.attachmentsByTestStepId = new multimaps_1.ArrayMultimap();
        this.stepMatchArgumentsListsByPickleStepId = new Map();
    }
    update(envelope) {
        if (envelope.testCase) {
            this.testCaseByPickleId.set(envelope.testCase.pickleId, envelope.testCase);
            for (const testStep of envelope.testCase.testSteps) {
                this.testStepById.set(testStep.id, testStep);
                this.pickleIdByTestStepId.set(testStep.id, envelope.testCase.pickleId);
                this.pickleStepIdByTestStepId.set(testStep.id, testStep.pickleStepId);
                this.testStepIdsByPickleStepId.put(testStep.pickleStepId, testStep.id);
                this.stepMatchArgumentsListsByPickleStepId.set(testStep.pickleStepId, testStep.stepMatchArgumentsLists);
            }
        }
        if (envelope.testStepFinished) {
            const pickleId = this.pickleIdByTestStepId.get(envelope.testStepFinished.testStepId);
            this.testStepResultByPickleId.put(pickleId, envelope.testStepFinished.testStepResult);
            const testStep = this.testStepById.get(envelope.testStepFinished.testStepId);
            this.testStepResultsByPickleStepId.put(testStep.pickleStepId, envelope.testStepFinished.testStepResult);
            this.testStepResultsbyTestStepId.put(testStep.id, envelope.testStepFinished.testStepResult);
        }
        if (envelope.hook) {
            this.hooksById.set(envelope.hook.id, envelope.hook);
        }
        if (envelope.attachment) {
            this.attachmentsByTestStepId.put(envelope.attachment.testStepId, envelope.attachment);
        }
    }
    /**
     * Gets all the results for multiple pickle steps
     * @param pickleStepIds
     */
    getPickleStepTestStepResults(pickleStepIds) {
        if (pickleStepIds.length === 0) {
            return [
                new messages_1.messages.TestStepFinished.TestStepResult({
                    status: messages_1.messages.TestStepFinished.TestStepResult.Status.UNKNOWN,
                    duration: messages_1.TimeConversion.millisecondsToDuration(0),
                }),
            ];
        }
        return pickleStepIds.reduce((testStepResults, pickleId) => {
            return testStepResults.concat(this.testStepResultsByPickleStepId.get(pickleId));
        }, []);
    }
    /**
     * Gets all the results for multiple pickles
     * @param pickleIds
     */
    getPickleTestStepResults(pickleIds) {
        if (pickleIds.length === 0) {
            return [
                new messages_1.messages.TestStepFinished.TestStepResult({
                    status: messages_1.messages.TestStepFinished.TestStepResult.Status.UNKNOWN,
                    duration: messages_1.TimeConversion.millisecondsToDuration(0),
                }),
            ];
        }
        return pickleIds.reduce((testStepResults, pickleId) => {
            return testStepResults.concat(this.testStepResultByPickleId.get(pickleId));
        }, []);
    }
    /**
     * Gets the worst result
     * @param testStepResults
     */
    getWorstTestStepResult(testStepResults) {
        return (testStepResults.slice().sort((r1, r2) => r2.status - r1.status)[0] ||
            new messages_1.messages.TestStepFinished.TestStepResult({
                status: messages_1.messages.TestStepFinished.TestStepResult.Status.UNKNOWN,
                duration: messages_1.TimeConversion.millisecondsToDuration(0),
            }));
    }
    /**
     * Gets all the attachments for multiple pickle steps
     * @param pickleStepIds
     */
    getPickleStepAttachments(pickleStepIds) {
        return this.getTestStepsAttachments(pickleStepIds.reduce((testStepIds, pickleStepId) => {
            return testStepIds.concat(this.testStepIdsByPickleStepId.get(pickleStepId));
        }, []));
    }
    getTestStepsAttachments(testStepIds) {
        return testStepIds.reduce((attachments, testStepId) => {
            return attachments.concat(this.attachmentsByTestStepId.get(testStepId));
        }, []);
    }
    /**
     * Get StepMatchArguments for a pickle step
     * @param pickleStepId
     */
    getStepMatchArgumentsLists(pickleStepId) {
        return this.stepMatchArgumentsListsByPickleStepId.get(pickleStepId);
    }
    getHook(hookId) {
        return this.hooksById.get(hookId);
    }
    getBeforeHookSteps(pickleId) {
        const hookSteps = [];
        this.identifyHookSteps(pickleId, (hook) => hookSteps.push(hook), () => null);
        return hookSteps;
    }
    getAfterHookSteps(pickleId) {
        const hookSteps = [];
        this.identifyHookSteps(pickleId, () => null, (hook) => hookSteps.push(hook));
        return hookSteps;
    }
    identifyHookSteps(pickleId, onBeforeHookFound, onAfterHookFound) {
        const testCase = this.testCaseByPickleId.get(pickleId);
        if (!testCase) {
            return;
        }
        let pickleStepFound = false;
        for (const step of testCase.testSteps) {
            if (step.hookId) {
                pickleStepFound ? onAfterHookFound(step) : onBeforeHookFound(step);
            }
            else {
                pickleStepFound = true;
            }
        }
    }
    getTestStepResults(testStepId) {
        return this.testStepResultsbyTestStepId.get(testStepId);
    }
}
exports.default = Query;
//# sourceMappingURL=Query.js.map