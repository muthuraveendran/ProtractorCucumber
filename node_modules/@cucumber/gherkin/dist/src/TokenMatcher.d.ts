import { messages } from '@cucumber/messages';
import IToken from './IToken';
import { TokenType } from './Parser';
import ITokenMatcher from './ITokenMatcher';
export default class TokenMatcher implements ITokenMatcher<TokenType> {
    private readonly defaultDialectName;
    private dialect;
    private dialectName;
    private activeDocStringSeparator;
    private indentToRemove;
    constructor(defaultDialectName?: string);
    changeDialect(newDialectName: string, location?: messages.ILocation): void;
    reset(): void;
    match_TagLine(token: IToken<TokenType>): boolean;
    match_FeatureLine(token: IToken<TokenType>): boolean;
    match_ScenarioLine(token: IToken<TokenType>): boolean;
    match_BackgroundLine(token: IToken<TokenType>): boolean;
    match_ExamplesLine(token: IToken<TokenType>): boolean;
    match_RuleLine(token: IToken<TokenType>): boolean;
    match_TableRow(token: IToken<TokenType>): boolean;
    match_Empty(token: IToken<TokenType>): boolean;
    match_Comment(token: IToken<TokenType>): boolean;
    match_Language(token: IToken<TokenType>): boolean;
    match_DocStringSeparator(token: IToken<TokenType>): boolean;
    _match_DocStringSeparator(token: IToken<TokenType>, separator: string, isOpen: boolean): boolean;
    match_EOF(token: IToken<TokenType>): boolean;
    match_StepLine(token: IToken<TokenType>): boolean;
    match_Other(token: IToken<TokenType>): boolean;
    matchTitleLine(token: IToken<TokenType>, tokenType: TokenType, keywords: readonly string[]): boolean;
    private setTokenMatched;
    private unescapeDocString;
}
//# sourceMappingURL=TokenMatcher.d.ts.map