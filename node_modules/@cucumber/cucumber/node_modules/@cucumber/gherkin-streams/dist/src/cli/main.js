"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const package_json_1 = __importDefault(require("../../package.json"));
const GherkinStreams_1 = __importDefault(require("../GherkinStreams"));
const messages_1 = require("@cucumber/messages");
const message_streams_1 = require("@cucumber/message-streams");
const program = new commander_1.Command();
program.version(package_json_1.default.version);
program.option('--no-source', 'Do not output Source messages', false);
program.option('--no-ast', 'Do not output GherkinDocument messages', false);
program.option('--no-pickles', 'Do not output Pickle messages', false);
program.option('--predictable-ids', 'Use predictable ids', false);
program.option('-f, --format <format>', 'output format: ndjson|protobuf', 'protobuf');
program.parse(process.argv);
const paths = program.args;
const options = {
    defaultDialect: 'en',
    includeSource: program.opts().source,
    includeGherkinDocument: program.opts().ast,
    includePickles: program.opts().pickles,
    newId: program.opts().predictableIds ? messages_1.IdGenerator.incrementing() : messages_1.IdGenerator.uuid(),
};
const messageStream = paths.length === 0
    ? GherkinStreams_1.default.fromStream(process.stdin, options)
    : GherkinStreams_1.default.fromPaths(paths, options);
let encodedStream;
switch (program.opts().format) {
    case 'ndjson':
        encodedStream = new message_streams_1.MessageToNdjsonStream();
        break;
    case 'protobuf':
        encodedStream = new message_streams_1.MessageToBinaryStream();
        break;
    default:
        throw new Error(`Unsupported format: ${program.opts().format}`);
}
messageStream.pipe(encodedStream).pipe(process.stdout);
//# sourceMappingURL=main.js.map