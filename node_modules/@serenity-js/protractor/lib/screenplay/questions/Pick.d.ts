import { AnswersQuestions, Expectation, MetaQuestion, Question, UsesAbilities } from '@serenity-js/core';
export interface Collection<T> {
    filter(fn: (item: T, index?: number) => boolean | Promise<boolean>): Collection<T>;
    map<O>(fn: (item: T, index?: number) => O): PromiseLike<O[]>;
    first(): T;
    last(): T;
    get(index: number): T;
    count(): PromiseLike<number> | number;
}
/**
 * @deprecated
 *  Please use [Target.all](/modules/protractor/class/src/screenplay/questions/targets/Target.ts~Target.html) instead.
 *
 * @experimental
 *
 * @see {@link @serenity-js/core/lib/screenplay/questions~List}
 */
export declare class Pick<Item_Type, Collection_Type extends Collection<Item_Type> = Collection<Item_Type>> {
    private readonly collection;
    private readonly filters;
    static from<IT, CT extends Collection<IT> = Collection<IT>>(collection: Question<CT> | CT): Pick<IT, CT>;
    constructor(collection: Question<Collection_Type> | Collection_Type, filters?: Filters<Item_Type, Collection_Type>);
    count(): Question<Promise<number>>;
    all(): Question<Collection_Type>;
    first(): Question<Item_Type>;
    last(): Question<Item_Type>;
    get(index: number): Question<Item_Type>;
    where<Property_Type>(question: MetaQuestion<Item_Type, Promise<Property_Type> | Property_Type>, expectation: Expectation<any, Promise<Property_Type> | Property_Type>): Pick<Item_Type, Collection_Type>;
}
/**
 * @package
 */
declare class Filters<Item_Type, Collection_Type extends Collection<Item_Type>> extends Question<(ct: Collection_Type) => Collection_Type> {
    private readonly filters;
    constructor(filters?: Array<Filter<Item_Type, Collection_Type, any>>);
    append(filter: Filter<Item_Type, Collection_Type, any>): Filters<Item_Type, Collection_Type>;
    /**
     * @desc
     *  Makes the provided {@link @serenity-js/core/lib/screenplay/actor~Actor}
     *  answer this {@link @serenity-js/core/lib/screenplay~Question}.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<void>}
     *
     * @see {@link @serenity-js/core/lib/screenplay/actor~Actor}
     * @see {@link @serenity-js/core/lib/screenplay/actor~AnswersQuestions}
     * @see {@link @serenity-js/core/lib/screenplay/actor~UsesAbilities}
     */
    answeredBy(actor: AnswersQuestions & UsesAbilities): (ct: Collection_Type) => Collection_Type;
}
/**
 * @package
 */
declare class Filter<Item_Type, Collection_Type extends Collection<Item_Type>, Property_Type> extends Question<(ct: Collection_Type) => Collection_Type> {
    private readonly question;
    private readonly expectation;
    constructor(question: MetaQuestion<Item_Type, Promise<Property_Type> | Property_Type>, expectation: Expectation<any, Promise<Property_Type> | Property_Type>);
    /**
     * @desc
     *  Makes the provided {@link @serenity-js/core/lib/screenplay/actor~Actor}
     *  answer this {@link @serenity-js/core/lib/screenplay~Question}.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<void>}
     *
     * @see {@link @serenity-js/core/lib/screenplay/actor~Actor}
     * @see {@link @serenity-js/core/lib/screenplay/actor~AnswersQuestions}
     * @see {@link @serenity-js/core/lib/screenplay/actor~UsesAbilities}
     */
    answeredBy(actor: AnswersQuestions & UsesAbilities): (ct: Collection_Type) => Collection_Type;
}
export {};
