"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stage = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../errors");
const events_1 = require("../events");
const model_1 = require("../model");
const actor_1 = require("../screenplay/actor");
/**
 * @desc
 *  The place where {@link Actor}s perform.
 *
 *  In more technical terms, the Stage is the main event bus propagating {@link DomainEvent}s
 *  to {@link Actor}s it instantiates and {@link StageCrewMember}s that have been registered with it.
 *
 * @see {@link configure}
 * @see {@link engage}
 */
class Stage {
    /**
     * @param {Cast} cast
     * @param {StageManager} manager
     */
    constructor(cast, manager) {
        this.cast = cast;
        this.manager = manager;
        /**
         * @desc
         *  Actors instantiated after the scene has started,
         *  who will be dismissed when the scene finishes.
         *
         * @private
         */
        this.actorsOnFrontStage = new Map();
        /**
         * @desc
         *  Actors instantiated before the scene has started,
         *  who will be dismissed when the test run finishes.
         *
         * @private
         */
        this.actorsOnBackstage = new Map();
        this.actorsOnStage = this.actorsOnBackstage;
        /**
         * @desc
         *  The most recent actor referenced via the {@link actor} method
         *
         * @private
         */
        this.actorInTheSpotlight = undefined;
        this.currentActivity = undefined;
        this.currentScene = new model_1.CorrelationId('unknown');
        tiny_types_1.ensure('Cast', cast, tiny_types_1.isDefined());
        tiny_types_1.ensure('StageManager', manager, tiny_types_1.isDefined());
    }
    /**
     * @desc An alias for {@link Stage#actor}
     * @see {@link Stage#actor}
     * @alias {Stage#actor}
     * @param {string} name
     * @return {Actor}
     */
    theActorCalled(name) {
        return this.actor(name);
    }
    /**
     * @desc Instantiates a new {@link Actor} or fetches an existing one
     * by their name if they've already been instantiated.
     *
     * @param {string} name - case-sensitive name of the Actor
     * @return {Actor}
     */
    actor(name) {
        if (!this.instantiatedActorCalled(name)) {
            let actor;
            try {
                const newActor = new actor_1.Actor(name, this);
                actor = this.cast.prepare(newActor);
                // todo this.manager.notifyOf(ActorStarts)
                // todo: map this in Serenity BDD Reporter so that the "cast" is recorded
            }
            catch (error) {
                throw new errors_1.ConfigurationError(`${this.typeOf(this.cast)} encountered a problem when preparing actor "${name}" for stage`, error);
            }
            if (!(actor instanceof actor_1.Actor)) {
                throw new errors_1.ConfigurationError(`Instead of a new instance of actor "${name}", ${this.typeOf(this.cast)} returned ${actor}`);
            }
            this.actorsOnStage.set(name, actor);
        }
        this.actorInTheSpotlight = this.instantiatedActorCalled(name);
        return this.actorInTheSpotlight;
    }
    /**
     * @desc
     *  Returns the last {@link Actor} instantiated via {@link Stage#actor}.
     *  Useful when you don't can't or choose not to reference the actor by their name.
     *
     * @throws {LogicError} if no {Actor} has been activated yet
     * @return {Actor}
     */
    theActorInTheSpotlight() {
        if (!this.actorInTheSpotlight) {
            throw new errors_1.LogicError(`There is no actor in the spotlight yet. Make sure you instantiate one with stage.actor(actorName) before calling this method.`);
        }
        return this.actorInTheSpotlight;
    }
    /**
     * @desc
     *  Returns {true} if there is an {@link Actor} in the spotlight, {false} otherwise.
     *
     * @return {boolean}
     */
    theShowHasStarted() {
        return !!this.actorInTheSpotlight;
    }
    /**
     * @desc
     *  Configures the Stage to prepare {@link Actor}s
     *  instantiated via {@link Stage#actor} using the provided {@link Cast}.
     *
     * @param {Cast} actors
     * @returns {void}
     */
    engage(actors) {
        tiny_types_1.ensure('Cast', actors, tiny_types_1.isDefined());
        this.cast = actors;
    }
    /**
     * @desc
     *  Assigns listeners to be notified of {@link DomainEvent}s
     *  emitted via {@link Stage#announce}
     *
     * @param {ListensToDomainEvents[]} listeners
     * @returns {void}
     */
    assign(...listeners) {
        this.manager.register(...listeners);
    }
    /**
     * @desc
     *  Notifies all the assigned listeners of the event.
     *
     * @listens {DomainEvent}
     *
     * @param {DomainEvent} event
     * @returns {void}
     */
    announce(event) {
        if (event instanceof events_1.SceneStarts) {
            this.actorsOnStage = this.actorsOnFrontStage;
        }
        this.manager.notifyOf(event);
        if (event instanceof events_1.SceneFinishes) {
            this.dismiss(this.actorsOnStage);
            this.actorsOnStage = this.actorsOnBackstage;
        }
        if (event instanceof events_1.TestRunFinishes) {
            this.dismiss(this.actorsOnStage);
        }
    }
    /**
     * @desc
     *  Returns current time. This method should be used whenever
     *  {@link DomainEvent} objects are instantiated by hand.
     *
     * @returns {Timestamp}
     */
    currentTime() {
        return this.manager.currentTime();
    }
    /**
     * @desc
     *  Generates and remembers a {@link CorrelationId}
     *  for the current scene.
     *
     *  This method should be used in custom test runner adapters
     *  when instantiating a {@link SceneStarts} event.
     *
     * @see {@link Stage#currentSceneId}
     *
     * @returns {CorrelationId}
     */
    assignNewSceneId() {
        // todo: inject an id factory to make it easier to test
        this.currentScene = model_1.CorrelationId.create();
        return this.currentScene;
    }
    /**
     * @desc
     *  Returns the {@link CorrelationId} for the current scene.
     *
     * @see {@link Stage#assignNewSceneId}
     *
     * @returns {CorrelationId}
     */
    currentSceneId() {
        return this.currentScene;
    }
    /**
     * @desc
     *  Generates and remembers a {@link CorrelationId}
     *  for the current {@link Activity}.
     *
     *  This method should be used in custom test runner adapters
     *  when instantiating an {@link ActivityStarts} event.
     *
     * @see {@link Stage#currentActivityId}
     *
     * @returns {CorrelationId}
     */
    assignNewActivityId() {
        // todo: inject an id factory to make it easier to test
        this.currentActivity = model_1.CorrelationId.create();
        return this.currentActivity;
    }
    /**
     * @desc
     *  Returns the {@link CorrelationId} for the current {@link Activity}.
     *
     * @see {@link Stage#assignNewSceneId}
     *
     * @returns {CorrelationId}
     */
    currentActivityId() {
        if (!this.currentActivity) {
            throw new errors_1.LogicError(`No activity is being performed. Did you call assignNewActivityId before invoking currentActivityId?`);
        }
        return this.currentActivity;
    }
    /**
     * @desc
     *  Returns a Promise that will be resolved when any asynchronous
     *  post-processing activities performed by Serenity/JS are completed.
     *
     * @returns {Promise<void>}
     */
    waitForNextCue() {
        return this.manager.waitForNextCue();
    }
    instantiatedActorCalled(name) {
        return this.actorsOnBackstage.has(name)
            ? this.actorsOnBackstage.get(name)
            : this.actorsOnFrontStage.get(name);
    }
    dismiss(activeActors) {
        const actors = Array.from(activeActors.values());
        if (actors.includes(this.actorInTheSpotlight)) {
            this.actorInTheSpotlight = undefined;
        }
        return Promise
            .all(actors.map(actor => {
            const id = model_1.CorrelationId.create();
            this.announce(new events_1.AsyncOperationAttempted(new model_1.Description(`[${this.constructor.name}] Dismissing ${actor.name}...`), id));
            return actor.dismiss()
                .then(() => this.announce(new events_1.AsyncOperationCompleted(new model_1.Description(`[${this.constructor.name}] Dismissed ${actor.name} successfully`), id)))
                .catch(error => this.announce(new events_1.AsyncOperationFailed(error, id)));
        }))
            .then(() => activeActors.clear());
    }
    /**
     * @private
     * @param {Cast} cast
     */
    typeOf(cast) {
        return this.cast.constructor !== Object
            ? this.cast.constructor.name
            : 'Cast';
    }
}
exports.Stage = Stage;
//# sourceMappingURL=Stage.js.map