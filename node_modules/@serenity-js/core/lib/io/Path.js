"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const tiny_types_1 = require("tiny-types");
const filenamify = require("filenamify");
const path = require("upath");
class Path extends tiny_types_1.TinyType {
    constructor(value) {
        super();
        tiny_types_1.ensure(Path.name, value, tiny_types_1.isDefined(), tiny_types_1.property('length', tiny_types_1.isGreaterThan(0)));
        this.value = path.normalize(value);
    }
    static fromJSON(v) {
        return new Path(v);
    }
    static from(...segments) {
        return new Path(path.joinSafe(...segments));
    }
    static fromSanitisedString(value) {
        const normalised = path.normalize(value).replace(/["'/:\\]/gi, ''), extension = path.extname(normalised), basename = path.basename(normalised, extension), filename = filenamify(basename, { replacement: '-', maxLength: 250 })
            .trim()
            .replace(/[\s-]+/g, '-');
        return new Path(path.join(path.dirname(normalised), `${filename}${extension}`));
    }
    join(another) {
        return new Path(path.join(this.value, another.value));
    }
    split() {
        return this.value
            .split(Path.Separator)
            .filter(segment => !!segment); // so that we ignore the trailing path separator in absolute paths
    }
    resolve(another) {
        return new Path(path.resolve(this.value, another.value));
    }
    directory() {
        return new Path(path.dirname(this.value));
    }
    basename() {
        return path.basename(this.value);
    }
    isAbsolute() {
        return path.isAbsolute(this.value);
    }
    root() {
        return new Path(path.parse(this.value).root);
    }
}
exports.Path = Path;
Path.Separator = '/';
//# sourceMappingURL=Path.js.map