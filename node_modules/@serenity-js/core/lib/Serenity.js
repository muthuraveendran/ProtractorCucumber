"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serenity = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("./errors");
const io_1 = require("./io");
const model_1 = require("./model");
const Clock_1 = require("./stage/Clock");
const Extras_1 = require("./stage/Extras");
const Stage_1 = require("./stage/Stage");
const StageManager_1 = require("./stage/StageManager");
class Serenity {
    /**
     * @param {Clock} clock
     */
    constructor(clock = new Clock_1.Clock()) {
        this.clock = clock;
        this.outputStream = process.stdout;
        this.stage = new Stage_1.Stage(Serenity.defaultActors, new StageManager_1.StageManager(Serenity.defaultCueTimeout, clock));
    }
    /**
     * @desc
     *  Configures Serenity/JS. Every call to this function
     *  replaces the previous configuration provided,
     *  so this function should called be exactly once
     *  in your test suite.
     *
     * @param {SerenityConfig} config
     * @return {void}
     */
    configure(config) {
        const looksLikeBuilder = io_1.has({ build: 'function' });
        const looksLikeStageCrewMember = io_1.has({ assignedTo: 'function', notifyOf: 'function' });
        const cueTimeout = config.cueTimeout
            ? tiny_types_1.ensure('cueTimeout', config.cueTimeout, tiny_types_1.isInstanceOf(model_1.Duration))
            : Serenity.defaultCueTimeout;
        if (config.outputStream) {
            this.outputStream = config.outputStream;
        }
        this.stage = new Stage_1.Stage(Serenity.defaultActors, new StageManager_1.StageManager(cueTimeout, this.clock));
        if (config.actors) {
            this.engage(config.actors);
        }
        if (Array.isArray(config.crew)) {
            this.stage.assign(...config.crew.map((stageCrewMember, i) => {
                if (looksLikeBuilder(stageCrewMember)) {
                    return stageCrewMember.build({ stage: this.stage, outputStream: this.outputStream });
                }
                if (looksLikeStageCrewMember(stageCrewMember)) {
                    return stageCrewMember.assignedTo(this.stage);
                }
                throw new errors_1.ConfigurationError(io_1.formatted `Entries under \`crew\` should implement either StageCrewMember or StageCrewMemberBuilder interfaces, \`${stageCrewMember}\` found at index ${i}`);
            }));
        }
    }
    /**
     * @desc
     *  Re-configures Serenity/JS with a new {@link Cast} of {@link Actor}s
     *  you'd like to use in any subsequent call to {@link actorCalled}.
     *
     *  This method provides an alternative to calling {@link Actor#whoCan}
     *  directly in your tests and you'd typically us it in a "before each"
     *  hook of your test runner of choice.
     *
     * @example <caption>Engaging a cast of actors</caption>
     *  import { Actor, Cast } from '@serenity-js/core';
     *
     *  class Actors implements Cast {
     *      prepare(actor: Actor) {
     *          return actor.whoCan(
     *              // ... abilities you'd like the Actor to have
     *          );
     *      }
     *  }
     *
     * engage(new Actors();
     *
     * @example <caption>Usage with Jasmine</caption>
     *  import 'jasmine';
     *
     *  beforeEach(() => engage(new Actors()));
     *
     * @example <caption>Usage with Cucumber</caption>
     *  import { Before } from 'cucumber';
     *
     *  Before(() => engage(new Actors());
     *
     * @param {Cast} actors
     * @returns {void}
     *
     * @see {@link Actor}
     * @see {@link Cast}
     */
    engage(actors) {
        this.stage.engage(tiny_types_1.ensure('actors', actors, tiny_types_1.property('prepare', tiny_types_1.isDefined())));
    }
    /**
     * @desc
     *  Instantiates or retrieves an actor {@link Actor}
     *  called `name` if one has already been instantiated.
     *
     * @example <caption>Usage with Jasmine</caption>
     *   import 'jasmine';
     *   import { actorCalled } from '@serenity-js/core';
     *
     *   describe('Feature', () => {
     *
     *      it('should have some behaviour', () =>
     *          actorCalled('James').attemptsTo(
     *              // ... activities
     *          ));
     *   });
     *
     * @example <caption>Usage with Cucumber</caption>
     *   import { actorCalled } from '@serenity-js/core';
     *   import { Given } from 'cucumber';
     *
     *   Given(/(.*?) is a registered user/, (name: string) =>
     *      actorCalled(name).attemptsTo(
     *              // ... activities
     *          ));
     *
     * @param {string} name
     *  The name of the actor to instantiate or retrieve
     *
     * @returns {Actor}
     *
     * @see {@link engage}
     * @see {@link Actor}
     * @see {@link Cast}
     */
    theActorCalled(name) {
        return this.stage.theActorCalled(name);
    }
    /**
     * @desc
     *  Retrieves an actor who was last instantiated or retrieved
     *  using {@link actorCalled}.
     *
     *  This function is particularly useful when automating Cucumber scenarios.
     *
     * @example <caption>Usage with Cucumber</caption>
     *   import { actorCalled } from '@serenity-js/core';
     *   import { Given, When } from 'cucumber';
     *
     *   Given(/(.*?) is a registered user/, (name: string) =>
     *      actorCalled(name).attemptsTo(
     *              // ... activities
     *          ));
     *
     *   When(/(?:he|she|they) browse their recent orders/, () =>
     *      actorInTheSpotlight().attemptsTo(
     *              // ... activities
     *          ));
     *
     * @returns {Actor}
     *
     * @see {@link engage}
     * @see {@link actorCalled}
     * @see {@link Actor}
     * @see {@link Cast}
     */
    theActorInTheSpotlight() {
        return this.stage.theActorInTheSpotlight();
    }
    announce(event) {
        this.stage.announce(event);
    }
    currentTime() {
        return this.stage.currentTime();
    }
    assignNewSceneId() {
        return this.stage.assignNewSceneId();
    }
    currentSceneId() {
        return this.stage.currentSceneId();
    }
    assignNewActivityId() {
        return this.stage.assignNewActivityId();
    }
    /**
     * @package
     */
    waitForNextCue() {
        return this.stage.waitForNextCue();
    }
}
exports.Serenity = Serenity;
Serenity.defaultCueTimeout = model_1.Duration.ofSeconds(5);
Serenity.defaultActors = new Extras_1.Extras();
//# sourceMappingURL=Serenity.js.map