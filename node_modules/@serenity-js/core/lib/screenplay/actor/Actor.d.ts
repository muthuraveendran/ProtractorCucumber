import { Artifact, Name } from '../../model';
import { Ability, AbilityType, Answerable } from '../../screenplay';
import { Stage } from '../../stage';
import { Activity } from '../Activity';
import { AnswersQuestions } from './AnswersQuestions';
import { CanHaveAbilities } from './CanHaveAbilities';
import { CollectsArtifacts } from './CollectsArtifacts';
import { PerformsActivities } from './PerformsActivities';
import { UsesAbilities } from './UsesAbilities';
export declare class Actor implements PerformsActivities, UsesAbilities, CanHaveAbilities<Actor>, AnswersQuestions, CollectsArtifacts {
    readonly name: string;
    private readonly stage;
    private readonly abilities;
    constructor(name: string, stage: Stage, abilities?: Map<AbilityType<Ability>, Ability>);
    /**
     * @desc
     *  Retrieves actor's {@link Ability} to `doSomething`.
     *
     *  Please note that this method performs an [`instancepf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)
     *  check against abilities given to this actor via {@link Actor#whoCan}. Please also note that {@link Actor#whoCan} performs
     *  the same check when abilities are assigned to the actor to ensure the actor has at most one instance of a given ability type.
     *
     * @param doSomething
     */
    abilityTo<T extends Ability>(doSomething: AbilityType<T>): T;
    /**
     * @desc
     *  Instructs the actor to attempt to perform a number of activities
     *  (see {@link Activity}, so either {@link Task}s or {@link Interaction}s)
     *  one by one.
     *
     * @param {...activities: Activity[]} activities
     * @return {Promise<void>}
     */
    attemptsTo(...activities: Activity[]): Promise<void>;
    /**
     * @desc
     *  Gives this Actor a list of abilities (see {@link Ability}) they can use
     *  to interact with the system under test or the test environment.
     *
     * @param {...Ability[]} abilities
     *  A vararg list of abilities to give the actor
     *
     * @returns {Actor}
     *  The actor with newly gained abilities
     *
     * @throws {ConfigurationError}
     *  Throws a ConfigurationError if the actor already has an ability of this type.
     */
    whoCan(...abilities: Ability[]): Actor;
    /**
     * @param {Answerable<T>} answerable - a Question<Promise<T>>, Question<T>, Promise<T> or T
     * @returns {Promise<T>} The answer to the Answerable
     */
    answer<T>(answerable: Answerable<T>): Promise<T>;
    /**
     * @desc
     *  Announce collection of an {@link Artifact} so that it can be picked up by a {@link StageCrewMember}.
     *
     * @param {Artifact} artifact
     * @param {?(string | Name)} name
     *
     * @returns {void}
     */
    collect(artifact: Artifact, name?: string | Name): void;
    /**
     * @desc
     *  Instructs the actor to invoke {@link Discardable#discard} method on any
     *  {@link Discardable} {@link Ability} it's been configured with.
     *
     * @returns {Promise<void>}
     */
    dismiss(): Promise<void>;
    /**
     * @desc
     *  Returns a human-readable, string representation of this Actor
     *
     * @returns {string}
     */
    toString(): string;
    /**
     * @private
     */
    private initialiseAbilities;
    /**
     * @param {...string[]} methodNames
     * @private
     */
    private findAbilitiesOfType;
    /**
     * @param {string} doSomething
     * @private
     */
    private findAbilityTo;
    /**
     * @desc
     *  Instantiates a {@link Name} based on the string value of the parameter,
     *  or returns the argument if it's already an instance of {@link Name}.
     *
     * @param {string | Name} maybeName
     * @returns {Name}
     *
     * @private
     */
    private nameFrom;
}
