"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actor = void 0;
const errors_1 = require("../../errors");
const events_1 = require("../../events");
const model_1 = require("../../model");
const activities_1 = require("../activities");
const Question_1 = require("../Question");
class Actor {
    // todo: Actor should have execution strategies
    // todo: the default one executes every activity
    // todo: there could be a dry-run mode that default to skip strategy
    constructor(name, stage, abilities = new Map()) {
        this.name = name;
        this.stage = stage;
        this.abilities = abilities;
    }
    /**
     * @desc
     *  Retrieves actor's {@link Ability} to `doSomething`.
     *
     *  Please note that this method performs an [`instancepf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)
     *  check against abilities given to this actor via {@link Actor#whoCan}. Please also note that {@link Actor#whoCan} performs
     *  the same check when abilities are assigned to the actor to ensure the actor has at most one instance of a given ability type.
     *
     * @param doSomething
     */
    abilityTo(doSomething) {
        const found = this.findAbilityTo(doSomething);
        if (!found) {
            throw new errors_1.ConfigurationError(`${this.name} can't ${doSomething.name} yet. ` +
                `Did you give them the ability to do so?`);
        }
        return found;
    }
    /**
     * @desc
     *  Instructs the actor to attempt to perform a number of activities
     *  (see {@link Activity}, so either {@link Task}s or {@link Interaction}s)
     *  one by one.
     *
     * @param {...activities: Activity[]} activities
     * @return {Promise<void>}
     */
    attemptsTo(...activities) {
        return activities
            .map(activity => new activities_1.TrackedActivity(activity, this.stage))
            .reduce((previous, current) => {
            return previous.then(() => {
                /* todo: add an execution strategy */
                return current.performAs(this);
            });
        }, this.initialiseAbilities());
    }
    /**
     * @desc
     *  Gives this Actor a list of abilities (see {@link Ability}) they can use
     *  to interact with the system under test or the test environment.
     *
     * @param {...Ability[]} abilities
     *  A vararg list of abilities to give the actor
     *
     * @returns {Actor}
     *  The actor with newly gained abilities
     *
     * @throws {ConfigurationError}
     *  Throws a ConfigurationError if the actor already has an ability of this type.
     */
    whoCan(...abilities) {
        abilities.forEach(ability => {
            const abilityType = ability.constructor;
            const found = this.findAbilityTo(abilityType);
            if (found) {
                const description = found.constructor.name === abilityType.name
                    ? found.constructor.name
                    : `${found.constructor.name} (which extends ${abilityType.name})`;
                throw new errors_1.ConfigurationError(`${this.name} already has an ability to ${description}, so you don't need to give it to them again.`);
            }
            this.abilities.set(ability.constructor, ability);
        });
        return this;
    }
    /**
     * @param {Answerable<T>} answerable - a Question<Promise<T>>, Question<T>, Promise<T> or T
     * @returns {Promise<T>} The answer to the Answerable
     */
    answer(answerable) {
        function isAPromise(v) {
            return !!v.then;
        }
        function isDefined(v) {
            return !(answerable === undefined || answerable === null);
        }
        if (isDefined(answerable) && isAPromise(answerable)) {
            return answerable;
        }
        if (isDefined(answerable) && Question_1.Question.isAQuestion(answerable)) {
            return this.answer(answerable.answeredBy(this));
        }
        return Promise.resolve(answerable);
    }
    /**
     * @desc
     *  Announce collection of an {@link Artifact} so that it can be picked up by a {@link StageCrewMember}.
     *
     * @param {Artifact} artifact
     * @param {?(string | Name)} name
     *
     * @returns {void}
     */
    collect(artifact, name) {
        this.stage.announce(new events_1.ActivityRelatedArtifactGenerated(this.stage.currentSceneId(), this.stage.currentActivityId(), this.nameFrom(name || new model_1.Name(artifact.constructor.name)), artifact, this.stage.currentTime()));
    }
    /**
     * @desc
     *  Instructs the actor to invoke {@link Discardable#discard} method on any
     *  {@link Discardable} {@link Ability} it's been configured with.
     *
     * @returns {Promise<void>}
     */
    dismiss() {
        return this.findAbilitiesOfType('discard')
            .reduce((previous, ability) => previous.then(() => ability.discard()), Promise.resolve(void 0));
    }
    /**
     * @desc
     *  Returns a human-readable, string representation of this Actor
     *
     * @returns {string}
     */
    toString() {
        const abilities = Array.from(this.abilities.keys()).map(type => type.name);
        return `Actor(name=${this.name}, abilities=[${abilities.join(', ')}])`;
    }
    /**
     * @private
     */
    initialiseAbilities() {
        return this.findAbilitiesOfType('initialise', 'isInitialised')
            .filter(ability => !ability.isInitialised())
            .reduce((previous, ability) => previous
            .then(() => ability.initialise())
            .catch(error => {
            throw new errors_1.TestCompromisedError(`${this.name} couldn't initialise the ability to ${ability.constructor.name}`, error);
        }), Promise.resolve(void 0));
    }
    /**
     * @param {...string[]} methodNames
     * @private
     */
    findAbilitiesOfType(...methodNames) {
        const abilitiesFrom = (map) => Array.from(map.values());
        const abilitiesWithDesiredMethods = (ability) => methodNames.every(methodName => typeof (ability[methodName]) === 'function');
        return abilitiesFrom(this.abilities)
            .filter(abilitiesWithDesiredMethods);
    }
    /**
     * @param {string} doSomething
     * @private
     */
    findAbilityTo(doSomething) {
        for (const [abilityType_, ability] of this.abilities) {
            if (ability instanceof doSomething) {
                return ability;
            }
        }
        return undefined;
    }
    /**
     * @desc
     *  Instantiates a {@link Name} based on the string value of the parameter,
     *  or returns the argument if it's already an instance of {@link Name}.
     *
     * @param {string | Name} maybeName
     * @returns {Name}
     *
     * @private
     */
    nameFrom(maybeName) {
        return typeof maybeName === 'string'
            ? new model_1.Name(maybeName)
            : maybeName;
    }
}
exports.Actor = Actor;
//# sourceMappingURL=Actor.js.map