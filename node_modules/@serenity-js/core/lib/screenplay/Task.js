"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Task = void 0;
const errors_1 = require("../errors");
/**
 * @desc
 *  Aggregates {@link Interaction}s so that they represents logical
 *  steps of a business process an {@link Actor} can perform.
 *
 * @implements {Activity}
 * @see {@link Interaction}
 * @see {@link Actor}
 */
class Task {
    /**
     * @desc
     *  A factory method to make defining the Tasks more convenient.
     *  Please note that calling this method without providing the list of {@link Activity} objects
     *  will result in producing a Task that's marked as "pending" in the test report.
     *
     *  This feature is useful when you want to quickly write down a task that will be needed in the scenario,
     *  but you're not yet sure what activities will constitute it.
     *
     * @example <caption>Modelling a task</caption>
     * import { Log, Task } from '@serenity-js/core';
     *
     * const Debug = (something: Answerable<any>) =>
     *     Task.where(`#actor prints the answer to a question`,
     *          Log.the(something),
     *     );
     *
     * @example <caption>Modelling a not implemented task</caption>
     * import { Task } from '@serenity-js/core';
     *
     * const SignUp = () =>
     *     Task.where(`#actor signs up for a newsletter`); // no activities given
     *                                                     // => task marked as pending
     *
     * @param {string} description - A description to be used when reporting this task
     * @param {Activity[]} activities - A list of lower-level activities that constitute the task
     *
     * @returns {Task}
     */
    static where(description, ...activities) {
        return activities.length > 0
            ? new DynamicallyGeneratedTask(description, activities)
            : new NotImplementedTask(description);
    }
}
exports.Task = Task;
/**
 * @package
 */
class DynamicallyGeneratedTask extends Task {
    constructor(description, activities) {
        super();
        this.description = description;
        this.activities = activities;
    }
    /**
     * @desc
     *  Makes the provided {@link Actor}
     *  perform this {@link Task}.
     *
     * @param {PerformsActivities} actor
     * @returns {Promise<void>}
     *
     * @see {@link Actor}
     * @see {@link PerformsActivities}
     */
    performAs(actor) {
        return actor.attemptsTo(...this.activities);
    }
    /**
     * @desc
     *  Generates a description to be used when reporting this {@link Activity}.
     *
     * @returns {string}
     */
    toString() {
        return this.description;
    }
}
/**
 * @package
 */
class NotImplementedTask extends Task {
    constructor(description) {
        super();
        this.description = description;
    }
    /**
     * @desc
     *  Makes the provided {@link Actor}
     *  perform this {@link Task}.
     *
     * @param {PerformsActivities} actor
     * @returns {Promise<void>}
     *
     * @see {@link Actor}
     * @see {@link PerformsActivities}
     */
    performAs(actor) {
        return Promise.reject(new errors_1.ImplementationPendingError(`A task where "${this.toString()}" has not been implemented yet`));
    }
    /**
     * @desc
     *  Generates a description to be used when reporting this {@link Activity}.
     *
     * @returns {string}
     */
    toString() {
        return this.description;
    }
}
//# sourceMappingURL=Task.js.map