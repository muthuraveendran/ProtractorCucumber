"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayListAdapter = void 0;
const tiny_types_1 = require("tiny-types");
const io_1 = require("../../../io");
const Question_1 = require("../../Question");
const expectations_1 = require("../expectations");
/**
 * @desc
 *  Adapts an {@link Array} so that it can be used with {@link List}
 *
 * @implements {ListAdapter}
 */
class ArrayListAdapter {
    /**
     * @param {Answerable<Item_Type[]>} array
     */
    constructor(array) {
        this.array = array;
    }
    /**
     * @desc
     *  Returns the number of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<number>}
     */
    count(actor) {
        return this.arrayAs(actor)
            .then(items => items.length);
    }
    /**
     * @desc
     *  Returns the underlying {@link Array},
     *  with any filters applied.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<number>}
     */
    items(actor) {
        return this.arrayAs(actor);
    }
    /**
     * @desc
     *  Returns the first of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<Item_Type>}
     */
    first(actor) {
        return this.arrayAs(actor)
            .then(items => this.getItemAt(items, 0));
    }
    /**
     * @desc
     *  Returns the nth of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     *
     * @param {number} index
     *  Zero-based index of the item to return
     *
     * @returns {Promise<Item_Type>}
     */
    get(actor, index) {
        return this.arrayAs(actor)
            .then(items => this.getItemAt(items, index));
    }
    /**
     * @desc
     *  Returns the last of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<Item_Type>}
     */
    last(actor) {
        return this.arrayAs(actor)
            .then(items => this.getItemAt(items, items.length - 1));
    }
    /**
     * @desc
     *  Filters the underlying {@link Array} so that the result contains only those items that meet the {@link Expectation}
     *
     * @param {MetaQuestion<Item_Type, Promise<Answer_Type> | Answer_Type>} question
     * @param {Expectation<any, Answer_Type>} expectation
     *
     * @returns {ListAdapter<Item_Type, Item_Type[], Promise<Item_Type>, Promise<Item_Type[]>>}
     *
     * @see {MetaQuestion}
     */
    withFilter(question, expectation) {
        return new ArrayListAdapter(new ArrayListFilter(this.array, question, expectation));
    }
    /**
     * @desc
     *  Returns a human-readable description of the underlying {@link Array}.
     *
     * @returns {string}
     */
    toString() {
        return io_1.formatted `${this.array}`;
    }
    arrayAs(actor) {
        return actor.answer(this.array)
            .then(array => tiny_types_1.ensure('ArrayListAdapter constructor parameter', array, tiny_types_1.isArray()));
    }
    getItemAt(items, index) {
        tiny_types_1.ensure('index', index, tiny_types_1.isNumber());
        const collectionDescription = this.toString();
        const itemsDescription = io_1.formatted `${items}`;
        const description = collectionDescription !== itemsDescription
            ? `${collectionDescription} ${itemsDescription}`
            : itemsDescription;
        if (items.length === 0) {
            throw new Error(`${description} is empty`);
        }
        if (index in items) {
            return items[index];
        }
        throw new Error(`${description} has no item at index ${index}`);
    }
}
exports.ArrayListAdapter = ArrayListAdapter;
/**
 * @package
 */
class ArrayListFilter extends Question_1.Question {
    constructor(collection, question, expectation) {
        super([
            io_1.formatted `${collection}`,
            collection instanceof ArrayListFilter ? 'and' : 'where',
            io_1.formatted `${question} does ${expectation}`
        ].join(' '));
        this.collection = collection;
        this.question = question;
        this.expectation = expectation;
    }
    answeredBy(actor) {
        return actor.answer(this.collection)
            .then(array => tiny_types_1.ensure('ArrayListAdapter constructor parameter', array, tiny_types_1.isArray())) // todo: extract to avoid duplication?
            .then(array => Promise.all(array.map(item => Promise.resolve(this.question.of(item).answeredBy(actor))
            .then(answer => this.expectation.answeredBy(actor)(answer))
            .then(outcome => ({ item, outcome })))))
            .then(results => results.filter(result => result.outcome instanceof expectations_1.ExpectationMet)
            .map(result => result.item));
    }
}
//# sourceMappingURL=ArrayListAdapter.js.map