import { AnswersQuestions, UsesAbilities } from '../../actor';
import { Answerable } from '../../Answerable';
import { Expectation } from '../Expectation';
import { MetaQuestion } from '../MetaQuestion';
import { ListAdapter } from './ListAdapter';
/**
 * @desc
 *  Adapts an {@link Array} so that it can be used with {@link List}
 *
 * @implements {ListAdapter}
 */
export declare class ArrayListAdapter<Item_Type> implements ListAdapter<Item_Type, Item_Type[], Promise<Item_Type>, Promise<Item_Type[]>> {
    private readonly array;
    /**
     * @param {Answerable<Item_Type[]>} array
     */
    constructor(array: Answerable<Item_Type[]>);
    /**
     * @desc
     *  Returns the number of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<number>}
     */
    count(actor: AnswersQuestions & UsesAbilities): Promise<number>;
    /**
     * @desc
     *  Returns the underlying {@link Array},
     *  with any filters applied.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<number>}
     */
    items(actor: AnswersQuestions & UsesAbilities): Promise<Item_Type[]>;
    /**
     * @desc
     *  Returns the first of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<Item_Type>}
     */
    first(actor: AnswersQuestions & UsesAbilities): Promise<Item_Type>;
    /**
     * @desc
     *  Returns the nth of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     *
     * @param {number} index
     *  Zero-based index of the item to return
     *
     * @returns {Promise<Item_Type>}
     */
    get(actor: AnswersQuestions & UsesAbilities, index: number): Promise<Item_Type>;
    /**
     * @desc
     *  Returns the last of items the underlying {@link Array} contains,
     *  left after applying any filters.
     *
     * @param {AnswersQuestions & UsesAbilities} actor
     * @returns {Promise<Item_Type>}
     */
    last(actor: AnswersQuestions & UsesAbilities): Promise<Item_Type>;
    /**
     * @desc
     *  Filters the underlying {@link Array} so that the result contains only those items that meet the {@link Expectation}
     *
     * @param {MetaQuestion<Item_Type, Promise<Answer_Type> | Answer_Type>} question
     * @param {Expectation<any, Answer_Type>} expectation
     *
     * @returns {ListAdapter<Item_Type, Item_Type[], Promise<Item_Type>, Promise<Item_Type[]>>}
     *
     * @see {MetaQuestion}
     */
    withFilter<Answer_Type>(question: MetaQuestion<Item_Type, Promise<Answer_Type> | Answer_Type>, expectation: Expectation<any, Answer_Type>): ListAdapter<Item_Type, Item_Type[], Promise<Item_Type>, Promise<Item_Type[]>>;
    /**
     * @desc
     *  Returns a human-readable description of the underlying {@link Array}.
     *
     * @returns {string}
     */
    toString(): string;
    private arrayAs;
    private getItemAt;
}
