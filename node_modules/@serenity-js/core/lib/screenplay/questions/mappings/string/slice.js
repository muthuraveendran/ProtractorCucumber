"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.slice = void 0;
/* eslint-disable unicorn/consistent-function-scoping */
const tiny_types_1 = require("tiny-types");
/**
 * @desc
 *  Extracts the part of the string between the `startIndex` and `endIndex` indexes, or to the end of the string if `endIndex` is `undefined`.
 *
 * @param {Answerable<number>} startIndex
 *  The zero-based index at which to begin extraction.
 *
 *  If negative, it is treated as `str.length + startIndex`. For example, if `startIndex` is `-3`, it is treated as `str.length - 3`
 *
 *  If `startIndex` is greater than or equal to `str.length`, an empty string is returned.
 *
 * @param {Answerable<number>} [endIndex]
 *  The zero-based index _before_ which to endIndex extraction.
 *  The character at this index will not be included.
 *
 *  If `endIndex` is omitted or undefined, or greater than `str.length`,
 *  `slice()` extracts to the endIndex of the string.
 *
 *  If negative, it is treated as `str.length + endIndex`.
 *  For example, if `endIndex` is `-3`, it is treated as `str.length - 3`.
 *
 * @returns {AnswerMappingFunction<string, string>}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring
 */
function slice(startIndex, endIndex) {
    return (actor) => (value) => {
        tiny_types_1.ensure('The value to be mapped', value, tiny_types_1.isDefined(), tiny_types_1.isString());
        return Promise.all([
            actor.answer(startIndex),
            actor.answer(endIndex),
        ]).then(([start, end]) => {
            tiny_types_1.ensure('startIndex', start, tiny_types_1.isDefined(), tiny_types_1.isInteger());
            if (end !== undefined) {
                tiny_types_1.ensure('endIndex', end, tiny_types_1.isInteger());
            }
            return value.slice(start, end);
        });
    };
}
exports.slice = slice;
//# sourceMappingURL=slice.js.map