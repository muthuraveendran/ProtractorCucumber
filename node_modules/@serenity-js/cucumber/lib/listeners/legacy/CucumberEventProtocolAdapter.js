"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cucumberEventProtocolAdapter = void 0;
const errors_1 = require("@serenity-js/core/lib/errors");
const io_1 = require("@serenity-js/core/lib/io");
const model_1 = require("@serenity-js/core/lib/model");
const tiny_types_1 = require("tiny-types");
const errors_2 = require("../../errors");
const gherkin_1 = require("./gherkin");
/**
 * @private
 */
function cucumberEventProtocolAdapter({ serenity, notifier, mapper, cache }) {
    return class CucumberEventProtocolAdapter {
        constructor({ eventBroadcaster, log }) {
            this.log = log;
            eventBroadcaster.on('gherkin-document', ({ uri, document }) => {
                tiny_types_1.ensure('gherkin-document :: uri', uri, tiny_types_1.isDefined());
                tiny_types_1.ensure('gherkin-document :: document', document, tiny_types_1.isDefined());
                const path = new io_1.Path(uri);
                cache.set(path, mapper.map(document, path));
            });
            eventBroadcaster.on('test-case-prepared', ({ steps, sourceLocation }) => {
                tiny_types_1.ensure('test-case-prepared :: steps', steps, tiny_types_1.isDefined());
                tiny_types_1.ensure('test-case-prepared :: sourceLocation', sourceLocation, tiny_types_1.isDefined());
                const path = new io_1.Path(sourceLocation.uri), map = cache.get(path), scenario = map.get(gherkin_1.Scenario).onLine(sourceLocation.line);
                if (scenario.outline) {
                    const outline = map.get(gherkin_1.ScenarioOutline).onLine(scenario.outline.line);
                    map.set(new gherkin_1.ScenarioOutline(outline.location, outline.name, outline.description, outline.steps, outline.parameters)).onLine(scenario.outline.line);
                }
                map.set(new gherkin_1.Scenario(scenario.location, scenario.name, scenario.description, interleaveStepsAndHooks(scenario.steps, steps), scenario.tags, scenario.outline)).onLine(sourceLocation.line);
            });
            eventBroadcaster.on('test-case-started', ({ sourceLocation }) => {
                tiny_types_1.ensure('test-case-started :: sourceLocation', sourceLocation, tiny_types_1.isDefined());
                const map = cache.get(new io_1.Path(sourceLocation.uri)), scenario = map.get(gherkin_1.Scenario).onLine(sourceLocation.line), sceneId = serenity.assignNewSceneId();
                if (scenario.outline) {
                    const outline = map.get(gherkin_1.ScenarioOutline).onLine(scenario.outline.line);
                    notifier.outlineDetected(sceneId, scenario, outline, map.getFirst(gherkin_1.Feature));
                }
                notifier.scenarioStarts(sceneId, scenario, map.getFirst(gherkin_1.Feature));
            });
            eventBroadcaster.on('test-step-started', ({ index, testCase }) => {
                tiny_types_1.ensure('test-step-started :: index', index, tiny_types_1.isDefined());
                tiny_types_1.ensure('test-step-started :: testCase', testCase, tiny_types_1.isDefined());
                const map = cache.get(new io_1.Path(testCase.sourceLocation.uri)), scenario = map.get(gherkin_1.Scenario).onLine(testCase.sourceLocation.line), step = scenario.steps[index];
                if (step instanceof gherkin_1.Step) { // ignore hooks
                    notifier.stepStarts(step);
                }
            });
            eventBroadcaster.on('test-step-finished', ({ index, result, testCase }) => {
                tiny_types_1.ensure('test-step-finished :: index', index, tiny_types_1.isDefined());
                tiny_types_1.ensure('test-step-finished :: result', result, tiny_types_1.isDefined());
                tiny_types_1.ensure('test-step-finished :: testCase', testCase, tiny_types_1.isDefined());
                const map = cache.get(new io_1.Path(testCase.sourceLocation.uri)), scenario = map.get(gherkin_1.Scenario).onLine(testCase.sourceLocation.line), step = scenario.steps[index];
                if (step instanceof gherkin_1.Step) { // ignore hooks
                    notifier.stepFinished(step, this.outcomeFrom(result));
                }
            });
            eventBroadcaster.on('test-case-finished', ({ result, sourceLocation }) => {
                tiny_types_1.ensure('test-case-finished :: result', result, tiny_types_1.isDefined());
                tiny_types_1.ensure('test-case-finished :: sourceLocation', sourceLocation, tiny_types_1.isDefined());
                const map = cache.get(new io_1.Path(sourceLocation.uri)), scenario = map.get(gherkin_1.Scenario).onLine(sourceLocation.line), nonHookSteps = scenario.steps.filter(step => step instanceof gherkin_1.Step);
                const outcome = nonHookSteps.length > 0
                    ? this.outcomeFrom(result)
                    : new model_1.ImplementationPending(new errors_1.ImplementationPendingError(`"${scenario.name.value}" has no test steps`));
                notifier.scenarioFinished(scenario, map.getFirst(gherkin_1.Feature), outcome);
            });
        }
        outcomeFrom(result) {
            const error = !!result.exception && this.errorFrom(result.exception);
            switch (result.status) {
                case 'undefined':
                    return new model_1.ImplementationPending(new errors_1.ImplementationPendingError('Step not implemented'));
                case 'ambiguous':
                case 'failed':
                    switch (true) {
                        case error instanceof errors_1.AssertionError: return new model_1.ExecutionFailedWithAssertionError(error);
                        case error instanceof errors_1.TestCompromisedError: return new model_1.ExecutionCompromised(error);
                        default: return new model_1.ExecutionFailedWithError(error);
                    }
                case 'pending':
                    return new model_1.ImplementationPending(new errors_1.ImplementationPendingError('Step not implemented'));
                case 'passed':
                    return new model_1.ExecutionSuccessful();
                case 'skipped':
                    return new model_1.ExecutionSkipped();
            }
        }
        errorFrom(exception) {
            switch (true) {
                case exception instanceof Error:
                    return exception;
                case typeof exception === 'string' && exception.startsWith('Multiple step definitions match'):
                    return new errors_2.AmbiguousStepDefinitionError(exception);
                default:
                    return io_1.ErrorSerialiser.deserialiseFromStackTrace(exception);
            }
        }
    };
}
exports.cucumberEventProtocolAdapter = cucumberEventProtocolAdapter;
/**
 * @private
 */
function interleaveStepsAndHooks(steps, stepsLocations) {
    const isAHook = (stepLocations) => stepLocations.actionLocation && !stepLocations.sourceLocation, matching = (location) => (step) => step.location.path.equals(new io_1.Path(location.sourceLocation.uri)) &&
        step.location.line === location.sourceLocation.line;
    return stepsLocations.map(location => isAHook(location)
        ? new gherkin_1.Hook(new io_1.FileSystemLocation(new io_1.Path(location.actionLocation.uri), location.actionLocation.line), new model_1.Name('Setup'))
        : steps.find(matching(location)));
}
//# sourceMappingURL=CucumberEventProtocolAdapter.js.map